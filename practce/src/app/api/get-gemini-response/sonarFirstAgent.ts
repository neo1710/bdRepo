

function toolTestSecret() {
    return "Testing tool this is my secret, do you mind?"
}

async function toolTestRealWeatherData(lat: string, lon: string) {
    try {
        const apiKey = process.env.NEXT_PUBLIC_WEATHER_API_KEY;
        if (!apiKey) throw new Error("Missing NEXT_PUBLIC_WEATHER_API_KEY");
        const url = `https://api.openweathermap.org/data/2.5/weather?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&appid=${apiKey}`;
        const resp = await fetch(url);
        if (!resp.ok) {
            throw new Error(`Weather API error: ${resp.status} ${resp.statusText}`);
        }
        const weatherJson = await resp.json();
        console.log("Weather data fetched successfully:", weatherJson);
        return weatherJson;
    } catch (err) {
        console.error("Error fetching weather data:", err);
        throw err;
    }
}

export const sonarFirstAgent = async (query: string) => {
    const perplexityUrl = "https://api.perplexity.ai/chat/completions";
    const perplexityApiKey = process.env.NEXT_PUBLIC_PERPLEXITY_API_KEY;
    const systemPrompt = `
 You are the first step in an AI agent and you job is to detect if user query requeres the use of a tool or not.
    If the user query requires tool then you must respond with the JSON object strcture bellow:
    If use wants to use the secret tool or asks for a secret message with the query you only job will to respond with this->
    {
    tool_name: "test_secret",
    tool_input: "nothing",
    tool_reasoning: "secret"
    } or
    if user wants to get real weather data first if user puts a location name fine the langitude and longitude to pass in the tool and if user simply put the langitude and longitude then respond with this->
    {
    tool_name: "get_real_weather_data",
    tool_input: {
        lat: "latitude",
        lon: "longitude"
    },
    tool_reasoning: "real_weather_data"
    }
    if user wants to get the answer without any tool specific requirement just respond to query also always provide answer in json format so that my parser does not throw an error.
 `; // Define your system prompt here
    try {
        const requestBody = {
            model: "sonar",
            messages: [
                {
                    role: "system",
                    content: systemPrompt
                },
                {
                    role: "user",
                    content: query
                }
            ]
        }
        const response = await fetch(perplexityUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${perplexityApiKey}`
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`Error: ${response.status} ${response.statusText}`);
        } else {
            const data = await response.json();
            const agentResponse = await JSON.parse(data.choices?.[0]?.message?.content);
            if (data.choices?.[0]?.message?.content && agentResponse?.tool_name === "test_secret") {
                console.log("Tool response generated by Sonar First Agent.");
                return JSON.stringify({
                    tool_response: toolTestSecret(),
                    user_query: query
                });
            }

            // If the sonar agent decided a tool call is required for real weather data,
            // call the weather tool and return the tool response (so the main route
            // can include it in the final Perplexity request just like other tools).
            if (data.choices?.[0]?.message?.content && agentResponse?.tool_name === "get_real_weather_data") {
                try {
                    const lat = agentResponse?.tool_input?.lat;
                    const lon = agentResponse?.tool_input?.lon;
                    if (!lat || !lon) throw new Error("Missing lat or lon in tool_input");

                    const weatherData = await toolTestRealWeatherData(String(lat), String(lon));

                    // Return a JSON string containing the tool response and original query.
                    return JSON.stringify({
                        tool_response: weatherData,
                        user_query: query
                    });
                } catch (err) {
                    console.error("Error during tool invocation:", err);
                    throw err;
                }
            }

            return data.choices?.[0]?.message?.content;
        }

    } catch (error) {
        console.error("Error in sonarFirstAgent:", error);
        throw error;
    }


}